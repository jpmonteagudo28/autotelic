{
  "hash": "b48637ff59b8bfba3e3b075cd7f4ffc5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapters 1–3\"\ndate: now\nformat:\n  html:\n    css: /learn/style.css\n    code-fold: false\n    code-link: true\n    code-tools: true\n    code-overflow: wrap\n    code-line-numbers: false\n#doi: 10.59350/wx5k1-ajc38\ncitation: false\ndraft: true\nhaiku:\n  - What's in a name?\n  - That which we call a rose\n  - by any other name would smell as sweet.\n---\n\n\n\n\n\n\n## What's in a name?\n\nIf you'd like to know your way around the programming environment, you first have to understand how R's OOP works. Binding is one of the most basic functions performed in `R` so let's start there:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- (1:6)\nprint(x)\n#| [1] 1 2 3 4 5 6\n```\n:::\n\n\n\n\nR assigns values to a name, and not vice-versa. This code is creating an object, a vector with 6 elements. This object is then bound to the name `x`– which is also a variable. The name acts as a reference to the values 1 through 6. This concept is clearly demonstrated by binding the existing values in x to y. This action doesn't create a copy of `(1:6)`, but binds the same values to a new name `y`. This doesn't mean that you won't see two names in your environment, instead, it shows that `y` is also referencing `(1:6)`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny <- x\n```\n:::\n\n\n\n\nHow do we know this? Well, we can access the object's identifier to make sure both `x` and `y` point to the same object `(1:6)`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint(lobstr::obj_addr(x))\n#| [1] \"0x2c05d4d5bd0\"\nprint(lobstr::obj_addr(y))\n#| [1] \"0x2c05d4d5bd0\"\n\n## Another example of this behavior\nprint(lobstr::obj_addr(mean))\n#| [1] \"0x2c058c0d440\"\nprint(lobstr::obj_addr(base::mean))\n#| [1] \"0x2c058c0d440\"\nprint(lobstr::obj_addr(match.fun(\"mean\")))\n#| [1] \"0x2c058c0d440\"\n```\n:::\n\n\n\n\n## Changes to a name\n\nThe naming possibilities seem endless, but they're actually limited. Always use syntactic names that consists of letters, digits, `.` and `_`. You can't begin with `_` or a digit, and can't use any **reserved words** like `TRUE`, `FALSE`,`NULL`,`if`, and `function`[^1]. To override these rules, you have to surround the name in back–ticks.\n\n[^1]: Check out the complete list of restricted names in `?Reserved`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`function` <- c(1:3,\"ay\", \"caramba\")\nprint(`function`)\n#| [1] \"1\"       \"2\"       \"3\"       \"ay\"      \"caramba\"\n\n`if` <- 1e+7\nprint(`if`)\n#| [1] 1e+07\n```\n:::\n\n\n\n\nWhat happens when I modify `y`? Do I get a new object or the same object, `\"0x1c7fb8fc418\"` with new values? A new object is created, but the original object `(1;6)`, did not change[^2]. R simply created a new object with one value changed, and rebound `y` to it.\n\n[^2]: **ALTREP**, or alternative representation, allows R to represent certain vectors in a very compact fashion. Number sequences are one example of this behavior since only the first and last numbers are stored. For this reason every sequence is the same size, 680B.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:6\ny <- x\ncat(tracemem(y), \"\\n\")\n#> <0000023889E515A0>\n\n# Modified object\ny[[6]] <- 10\n\n#> tracemem[0x0000023889e515a0 -> 0x0000023891546ef8]: \n#> tracemem[0x0000023891546ef8 -> 0x0000023890d854f8]: \n\nuntracemem(y) # to stop tracing y\n\n# Using a function to test this concept\nf <- function(a){\n  a\n}\n\ncat(tracemem(x), \"\\n\")\n\nz <- f(x)\n# no copy made. Bound z to (1:6)\n\nuntracemem(x)\n```\n:::\n\n\n\n\nWe just performed **copy-on modify**[^3] and, hopefully, realized that R objects are immutable– once created, it will stay unchanged[^4].\n\n[^3]: If an object has a single name bound to it, R will **modify–in–place**–the new value will be appended to the same object.\n\n[^4]: When an object is not longer bound to a name, the garbage collector will delete it to free up memory\n\n### Lists\n\nLists store elements that point to a specific value, just like variables; however, R uses **shallow** copy–on modify when binding values to a new list. In other words, the list object and its bindings are copied, but not the values to which the elements are pointing.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nl1 <- list(c(1:4),\"a\")\nlobstr::obj_addr(l1)\n#| [1] \"0x2c05f625418\"\n\nl2 <- l1\nlobstr::obj_addr(l2)\n#| [1] \"0x2c05f625418\"\n\n# Modify l2\nl2[[3]] <- 25\nlobstr::obj_addr(l2)\n#| [1] \"0x2c05ee6e938\"\n\n## Let's look at values shared across lists\nlobstr::ref(l1,l2)\n#| █ [1:0x2c05f625418] <list> \n#| ├─[2:0x2c05f625518] <int> \n#| └─[3:0x2c05d9b8660] <chr> \n#|  \n#| █ [4:0x2c05ee6e938] <list> \n#| ├─[2:0x2c05f625518] \n#| ├─[3:0x2c05d9b8660] \n#| └─[5:0x2c05d9b84d8] <dbl>\n```\n:::\n\n\n\n\n### Data frames\n\nData frames are lists of vectors so modifying a column– one list– will not affect the binding of the other columns. However, modifying a row forces R to copy every column in the data frame.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nd1 <- data.frame(x = (1:6), y = (7:12))\nlobstr::obj_addr(d1)\n#| [1] \"0x2c05ee95ad8\"\n\nd2 <- d1\nlobstr::obj_addr(d2)\n#| [1] \"0x2c05ee95ad8\"\n\n# Modify one column\nd2[,2] <- d2[,2] * 3\nref(d1,d2)\n#| █ [1:0x2c05ee95ad8] <df[,2]> \n#| ├─x = [2:0x2c05e05aec8] <int> \n#| └─y = [3:0x2c05e05adb0] <int> \n#|  \n#| █ [4:0x2c05f58e078] <df[,2]> \n#| ├─x = [2:0x2c05e05aec8] \n#| └─y = [5:0x2c05f740238] <dbl>\n\n# Modify one row\nd3 <- d1\nd3[1,]<- d3[1,] *3\nref(d1,d3)\n#| █ [1:0x2c05ee95ad8] <df[,2]> \n#| ├─x = [2:0x2c05e05aec8] <int> \n#| └─y = [3:0x2c05e05adb0] <int> \n#|  \n#| █ [4:0x2c05efb20c8] <df[,2]> \n#| ├─x = [5:0x2c05f0e2268] <dbl> \n#| └─y = [6:0x2c05f0e20a8] <dbl>\n```\n:::\n\n\n\n\n### Character vectors\n\nR uses a global string pool where each element in a character vector is a pointer to a unique string in the pool.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchar <- c(\"a\",\"a\",\"abc\",\"d\")\nlobstr::ref(char, character = T)\n#| █ [1:0x2c05f57bc58] <chr> \n#| ├─[2:0x2c058192780] <string: \"a\"> \n#| ├─[2:0x2c058192780] \n#| ├─[3:0x2c05e493490] <string: \"abc\"> \n#| └─[4:0x2c0586af9c0] <string: \"d\">\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](../img/character-2.png){fig-align='center'}\n:::\n:::\n\n\n\n\n#### A little bit of **fun**ctions\n\nLet's see how R's binding behavior affects performance by using two simple functions and comparing the speed as the number of columns increase.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define function to create random data\nmake.rand <- function(nrow,ncol){\n  set.seed(2899)\n  ran.matrix <- matrix(runif(nrow * ncol)\n                       ,nrow = nrow)\n  as.data.frame(ran.matrix)\n}\n\n# Create function to perform simple operation on:\n# Data frames\nsum.df <- function(x,means){\n  means <- vapply(x,mean,numeric(1))\n  for(i in seq_along(means)){\n    x[[i]] <- x[[i]] + means[[i]]\n  }\n  x\n}\n\n# and lists\nsum.list <- function(x,means){\n  x <- as.list(x)\n  x <- sum.df(x,means)\n  list2DF(x) # using list2DF to level performance of both functions\n}\n\nmake.rand(2,2) # testing function with 2×2 matrix\n#|      V1     V2\n#| 1 0.250 0.7588\n#| 2 0.422 0.0154\n```\n:::\n\n\n\n\n::: {.callout-tip appearance=\"simple\"}\nAs a rule of thumbs, initialize vectors outside of loops. Move the computation of the `means` vector inside the `for` loop, and you will notice a 17,000% increase in computation time.\n:::\n\nI've created two functions to wrap the mean addition of a data frame and a list of randomly generated data. Next, I'll create a function to evaluate performance of each operation on `dfs` and `lists` and thus the overhead of `for` loops[^5].\n\n[^5]: each iteration of the loop copies the data frame three times. Ideally, this behavior is reduced by using lists\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Function to create ran. data, calc. mean add., and eval. performance.\nbench.means <- function(ncol){\n  df <- make.rand(nrow = 1e4,ncol = ncol)\n  means <- vapply(df,mean,numeric(1), USE.NAMES = F)\n  \n  bench::mark(\"data frame\" = sum.df(df,means),\n              \"list\" = sum.list(df,means),\n              time_unit = \"ms\")\n}\n\nbench.means(1) # testing function w. 1 column\n#| # A tibble: 2 × 6\n#|   expression    min median `itr/sec` mem_alloc `gc/sec`\n#|   <bch:expr>  <dbl>  <dbl>     <dbl> <bch:byt>    <dbl>\n#| 1 data frame 0.0465  0.101     8674.   105.2KB     12.2\n#| 2 list       0.0628  0.125     6680.    93.3KB     11.6\n```\n:::\n\n\n\n\nUsing `bench::press()` I'll iterate over a vector of columns to evaluate performance speed as `ncol` increases and then visualize the execution time for data frames and lists.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n\nresults <- bench::press(\n  ncol = c(1,10,35,75,100,300,500,650,800),\n  bench.means(ncol)\n)\n\n# Customize fonts\nfont_add_google(\"Libre Franklin\",\"libre\")\nshowtext_auto()\ntext <- \"libre\"\n\n# Custom color palette\ncols <- c(\"#80ADBF\",\"#7c225c\")\n\n# Create custom plot\nggplot(results,\n       aes(ncol,median,col = attr(expression,\"description\"))) +\n  geom_point() +\n  geom_smooth(se = FALSE) +\n  labs(x = \"Number of columns\",\n       y = \"Execution Time (ms)\",\n       colour = \"Data Structure\") +\n  scale_color_manual(values = cols) +\n  theme_minimal() +\n  theme(legend.position = \"top\",\n        legend.title = element_text(family = text, size = 23),\n        legend.text = element_text(family = text, size = 18),\n        plot.background = element_rect(fill = \"#dfe8f3\",\n                                       color = \"NA\"),\n        axis.title = element_text(family = text, size = 18,\n                                  hjust = .5),\n        axis.text = element_text(family = text,size = 16),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()\n        )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plots-1.png){fig-align='center' width=90%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- make.rand(nrow = 1e4,ncol = 5)\nmeans <- vapply(x,mean,numeric(1))\n\nfor(i in seq_along(means)){\n  x[[i]] <- x[[i]] + means[[i]]\n}\n\n# How many times is the data frame copied during one iteration?\ncat(tracemem(x), \"\\n\")\n# <0x000001b594610f08>\n\nfor(i in 1:2){\n  x[[i]] <- x[[i]] + means[[i]]\n}\n\n# tracemem[0x000001b594610f08 -> 0x000001b597fb9468]\n# tracemem[0x000001b597fb9468 -> 0x000001b597fb93f8]: [[<-.data.frame [[<-\n# tracemem[0x000001b597fb93f8 -> 0x000001b597fb9388]\n# tracemem[0x000001b597fb9388 -> 0x000001b597fb9318]: [[<-.data.frame [[<-\n\nuntracemem(x)\n```\n:::\n\n\n\n\nThe execution time for a data frame is significantly higher after a few hundred columns are added. R's copy-on modify behavior creates three copies of the data frame with each iteration of the `for` loop while a list is only copied once. This behavior is not problematic for a few columns so this approach may not pay off.\n\n## Vectors\n\nVectors come in two flavors, atomic^[when the inputs of a vector are atomic, the resulting vector will also be atomic. This is called flattening.] and lists. There are four primary types of atomic vectors: logical, integer, double, and character. We refer to integer and double vectors as numeric. There are also complex and raw vectors to deal with complex numbers and binary data^[Review the documentation for `as.raw()` and `as.complex()`.].\n\n\n\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 4\nflowchart LR\n  A[Logical] ---> B((Atomic))\n  B --> C{Vector}\n  E(Numeric) --> B\n  D[Character] ---> B\n  F[Double] --> E\n  G[Integer] --> E\n```\n\n\n\n\n\nTo create scalars^[a special syntax to create an individual value] of each type of atomic vectors we use `TRUE` or `FALSE`^[also abbreviated as `T` and `F`] for logicals. Doubles are specified in decimal, scientific or hexadecimal form and can take three special forms, `Inf`, `-Inf`, and `NaN`. Integers are written like doubles but must be followed by L, while strings are surrounded by `\"` or `'`. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndbl <- c(1.2,2.45,3.0)\nint <- c(1,6,10,4)\nlog <- c(TRUE,FALSE,TRUE,FALSE)\nchar <- c(\"TRUE\",\"FALSE\",\"TRUE\",\"FALSE\")\n\ntypeof(dbl); length(dbl)\n#| [1] \"double\"\n#| [1] 3\ntypeof(int); length(int)\n#| [1] \"double\"\n#| [1] 4\ntypeof(log); length(log)\n#| [1] \"logical\"\n#| [1] 4\ntypeof(char); length(char)\n#| [1] \"character\"\n#| [1] 4\n\n# NA values\n# Most computations involving a missing value will return a missing value\nNA * 5\n#| [1] NA\nNA > 10\n#| [1] NA\n!NA\n#| [1] NA\nNA^0\n#| [1] 1\nNA | TRUE # TRUE has a value of 1\n#| [1] TRUE\nNA & FALSE # FALSE has a value of 0\n#| [1] FALSE\n\n# Missing values propagate\nx <- c(NA,5,10,13,NA)\nx == NA\n#| [1] NA NA NA NA NA\n#Use is.na() instead\nis.na(x)\n#| [1]  TRUE FALSE FALSE FALSE  TRUE\n```\n:::\n\n\n\n\nInstead of testing whether you're working with a vector using `is.vector()` or `is.atomic()`, or `is.numeric()`^[These commands don't test if you have a vector. Review the documentation to figure out what they do.]; use more specific commands like `is.logical()`, `is.double()`, `is.integer()`,`is.character()`. For atomic vectors, type is a property of the entire vector– all elements must be of the same type. This will be forcibly achieved by automatic **coercion** in a pre-determined order:\n\n\n\n\n```{mermaid}\n%%| echo: false\n%%|fig-width: 4\nflowchart LR\nA(character) --> B(double) \nB --> C(integer) \nC --> D(logical)\n```\n\n\n\n\nYou can deliberately coerce an object by using `as.*()`; however, you run the risk of producing NA if the object cannot be coerced, i.e, coercing character strings to numeric objects. \n\n### Attributes\n\nVectors do not include matrices, arrays,factors, or date–time objects. These types are built as attributes of a vector. These attributes are name–value pairs that attach metadata to an object. You can set attributes with `structure()`, and retrieved with `attr()` and `attributes()`, individually or collectively. However, most attributes, except `names` and `dim`, are lost by most operations, unless you create an S3 class for them. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- 1:3\na <- structure(1:3,\n  x = \"ay\",\n  y = \"caramba\"\n)\n\nstr(attributes(a))\n#| List of 2\n#|  $ x: chr \"ay\"\n#|  $ y: chr \"caramba\"\n\n#Don't use attr(a,\"names\") to assign names to elements in an object.\n# Instead use one of these three options:\nb <- c(d = c(\"1,2,3\"),e = \"ay\", f = \"caramba\") \n\n# or use names()#\nb <- c(\"1,2,3\",\"ay\",\"caramba\")\nnames(b) <- c(\"d\",\"e\",\"f\")\n\n# or Inline, with setNames #\nb <- setNames(c(\"1,2,3\",\"ay\",\"caramba\"), c(\"d\",\"e\",\"f\"))\n```\n:::\n\n\n\n\nThe `dim` attribute allows a vector to behave like a two–dimensional matrix or a multi–dimensional array. Matrices and arrays can therefore be created in place by using the `dim()` command or `matrix()` and `array()`\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\nTable: Command Generalizations\n\n     Vector                 Matrix                Array      \n-----------------  ------------------------  ----------------\n     names()        rownames(), colnames()      dimnames()   \n    length()            nrow(), ncol()            dim()      \n       c()             rbind(),cbind()        abind::abind() \n        —                    t()                 aperm()     \n is.null(dim(x))         is.matrix()            is.array()   \n\n\n:::\n:::\n\n\n\n\n### S3 Vectors\n\nThe `class` attribute turns vectors into S3 objects. S3 objects are built on top of a base type, and store additional information in other attributes. Four important S3 vectors used in R are **factors**, categorical data with values represening a fixed set of levels;**date** vectors, **date—times** stored in **POSIXct**, and **difftime** to represent durations. \n\n\n\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 4\nflowchart LR\n  A[Logical] ---> B((Atomic))\n  B --> C{Vector}\n  E(Numeric) --> B\n  D[Character] ---> B\n  F[Double] --> E\n  G[Integer] --> E\n  H[/factor/] -->G\n  I[/POSIXct/] -->F\n  J[/Date/] --> F\n```\n\n\n\n#### Factors\n\nFactors are built on top of an integer vector with two attributes: a `class` “factor” and `levels`to define the set of allowed values. Tabulating factor vectors will get you a count of all categories, observed and unobserved, which is not the case with character vectors. **Ordered** factors are a variation of factors where the order of levels is meaningful(poor, good, best).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- factor(c(\"ay\", \"ay\",\"caramba\",\"caramba\",\"123\"))\nprint(f)\n#| [1] ay      ay      caramba caramba 123    \n#| Levels: 123 ay caramba\n\ntypeof(f)\n#| [1] \"integer\"\n\n# Factor levels count\ngender <- c(\"m\",\"m\",\"m\")\ngender_factor <- factor(gender, levels = c(\"m\",\"f\"))\n\n# Tabulate\ntable(gender)\n#| gender\n#| m \n#| 3\ntable(gender_factor)\n#| gender_factor\n#| m f \n#| 3 0\n\n# Ordered Factors\nhealth <- ordered(c(\"poor\",\"good\",\"poor\",\"best\",\"good\"), \n                  levels = c(\"poor\",\"good\",\"best\"))\nprint(health)\n#| [1] poor good poor best good\n#| Levels: poor < good < best\n```\n:::\n\n\n\n\n#### Dates & Date—times\n\nDate vectors are built on top of double vectors and only have one attribute, `class`. The value of the double vector, after stripping the class, represents the number of days since the Unix epoch(1970-01-01).\n\nDate—times vector come in two formats, POSIXct and POSIXlt, built on top of double vectors, where the values of POSIXct, calendar time, represents the number of seconds since the Unix epoch.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\n\ntypeof(today)\n#| [1] \"double\"\nattributes(today)\n#| $class\n#| [1] \"Date\"\n\ndate <- as.Date(\"1970-02-02\")\nunclass(date)\n#| [1] 32\n\n# Date-times\npoint_ct <- as.POSIXct(\"2020-02-02\", tz = \"UTC\") # tz is timezone\nprint(point_ct)\n#| [1] \"2020-02-02 UTC\"\ntypeof(point_ct)\n#| [1] \"double\"\nattributes(point_ct)\n#| $class\n#| [1] \"POSIXct\" \"POSIXt\" \n#| \n#| $tzone\n#| [1] \"UTC\"\n```\n:::\n\n\n\n\n#### Durations\n\nDurations represent the amount of time between pairs of dates or date—times stored as “difftimes”. Difftimes are also built on top of doubles and have a `units` attribute that determines how the integer is interpreted.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nweek <- as.difftime(1,units = \"weeks\")\nprint(week)\n#| Time difference of 1 weeks\ntypeof(week)\n#| [1] \"double\"\nattributes(week)\n#| $class\n#| [1] \"difftime\"\n#| \n#| $units\n#| [1] \"weeks\"\n\nweek_days <- as.difftime(7,units = \"days\")\nprint(week_days)\n#| Time difference of 7 days\ntypeof(week_days)\n#| [1] \"double\"\nattributes(week_days)\n#| $class\n#| [1] \"difftime\"\n#| \n#| $units\n#| [1] \"days\"\n```\n:::\n\n\n\n\n### Lists\n\nLists are one level above atomic vectors and can contain  elements of any type, not just vectors. Lists are constructed with the `list()` command. Because elements in a list are really just references to objects, creating a list doesn't involve copying the objects into the list. In general, lists can contain any vector, matrix, data frame or array. Lists are also recursive because they can contain other lists, which makes them fundamentally different from vectors. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#lists can contain any objects(vector, df, matrix)\nl1 <- list(c(1:6, mtcars,matrix(1:20,4,5)))\ntypeof(l1)\n#| [1] \"list\"\n# Lists are smaller than expected\nlobstr::obj_size(l1)\n#| 6.33 kB\n\n# Recursive property\nl2 <- list(list(list(1:200)))\nlobstr::obj_size(l2)\n#| 848 B\nstr(l2)\n#| List of 1\n#|  $ :List of 1\n#|   ..$ :List of 1\n#|   .. ..$ : int [1:200] 1 2 3 4 5 6 7 8 9 10 ...\n\n# Turn list into vector…and face the consequences\n#| unlist(l1)\n```\n:::\n\n\n\n\n### Matrices & Arrays\n\nMatrices and arrays are created by using the dimension attribute of atomic vectors. We can also create list–matrices and list–arrays by means of the   `dim` attribute. These structures can be helpful for modeling objects on a spatio–temporal 3D grid. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nl3 <- list(1:6, a:f,1.25, c(T,F,T,F,F))\ndim(l3) <- c(2,2)\nprint(l3)\n#|      [,1]      [,2]     \n#| [1,] integer,6 1.25     \n#| [2,] integer,2 logical,5\n\n# select 1 col, row 1\nl3[[1,1]]\n#| [1] 1 2 3 4 5 6\n```\n:::\n\n\n\n\n### Data frames & Tibbles\n\nA data frame is a named list of vectors with attributes for `names` of columns and `row.names`, and its class `data.frame`. Data frames must be made up of vectors of equal length since by definition, they must be rectangular structures.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:6, y = letters[1:6])\ntypeof(df1)\n#| [1] \"list\"\n\nattributes(df1)\n#| $names\n#| [1] \"x\" \"y\"\n#| \n#| $class\n#| [1] \"data.frame\"\n#| \n#| $row.names\n#| [1] 1 2 3 4 5 6\n\n# no. of columns\nlength(df1)\n#| [1] 2\n\n# Column names\nnames(df1)\n#| [1] \"x\" \"y\"\n```\n:::\n\n\n\n\nTibbles are provided by the `tibble` package. They're very similar to data frames, except that the class vector is longer, and they don't coerce their input. \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf2 <- tibble::tibble(x = 1:6, y = letters[1:6])\ntypeof(df2)\n#| [1] \"list\"\n\nattributes(df2)\n#| $class\n#| [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#| \n#| $row.names\n#| [1] 1 2 3 4 5 6\n#| \n#| $names\n#| [1] \"x\" \"y\"\n\nlength(df2)\n#| [1] 2\n\nnames(df2)\n#| [1] \"x\" \"y\"\n```\n:::\n\n\n\n\nBoth, data frames and tibbles, do recycle shorter inputs; however, recycling only occur for columns that are integer multiples of the longest column and for vectors of length one, respectively. Finally, tibbles do allow you to call other variables during construction.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata.frame(x = 1:6, y = 1:3)\n#| x y\n#| 1 1 1\n#| 2 2 2\n#| 3 3 3\n#| 4 4 1\n#| 5 5 2\n#| 6 6 3\ndata.frame(x = 1:7, y = 1:3)\n#| Error in `data.frame()`:! arguments imply differing number of rows: 7, 3\n\ntibble::tibble(x = 1:4, y = 1)\n#| # A tibble: 4 × 2\n#|     x     y\n#| 1     1     1\n#| 2     2     1\n#| 3     3     1\n#| 4     4     1\ntibble::tibble(x = 1:4, y = 1:2)\n#| Error in `tibble::tibble()`: ! Tibble columns must have compatible sizes.\n#| • Size 4: Existing data.\n#| • Size 2: Column `y`.\n#| ℹ Only values of size one are recycled.\n#| \ndata.frame(x = 1:4, y = x * 2)\n#| Error: object 'x' not found\n#| \ntibble::tibble(x = 1:4, y = x * 2)\n# A tibble: 4 × 2\n#|      x     y\n#|  <int> <dbl>\n#| 1     1     2\n#| 2     2     4\n#| 3     3     6\n#| 4     4     8\n```\n:::\n\n\n\n\nYou can also create data frames and tibbles with list columns by either adding the list/matrix after creating the data frame or by wrapping it in `I()`^[Review the documentation for `AsIs()`]. Matrices, on the other hand, must have the same number of rows as the data frame.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Add after creation\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3,1:4)\n\n# Use I()\ndata.frame(x = 1:3, \n          y = I(list(1:2, 1:3,1:4)))\n#|   x          y\n#| 1 1       1, 2\n#| 2 2    1, 2, 3\n#| 3 3 1, 2, 3, 4\n\n# Tibbles can have lists direclty included\ntibble::tibble(x = 1:3, \n               y = list(1:2, 1:3, 1:4))\n#| # A tibble: 3 × 2\n#|       x y        \n#|   <int> <list>   \n#| 1     1 <int [2]>\n#| 2     2 <int [3]>\n#| 3     3 <int [4]>\n\n# Matrices are added after creation\ndfmat <- data.frame(x = 1:3 * 5)\ndfmat$y <- matrix(1:15, nrow = 3) # same no. of rows as dfmat\n\nstr(dfmat)\n#| 'data.frame':\t3 obs. of  2 variables:\n#|  $ x: num  5 10 15\n#|  $ y: int [1:3, 1:5] 1 2 3 4 5 6 7 8 9 10 ...\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}