{
  "hash": "129df8f6a3fdbe29ba8ff974b645d4e6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapters 1–4\"\ndate: now\nformat:\n  html:\n    css: /learn/style.css\n    code-fold: false\n    code-tools: true\n    code-overflow: wrap\n    code-line-numbers: false\n#doi: 10.59350/wx5k1-ajc38\ncitation: false\n#draft: true\nhaiku:\n  - What's in a name?\n  - That which we call a rose\n  - by any other name would smell as sweet.\n---\n\n\n\n\n## What's in a name?\n\nIf you'd like to know your way around the programming environment, you first have to understand how R's OOP works. Binding is one of the most basic functions performed in `R`.So let's start there:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- (1:6)\nprint(x)\n## [1] 1 2 3 4 5 6\n```\n:::\n\n\nThis code is creating an object, a vector with 6 elements. This object is then bound to the name `x`. R assigns values to a name, and not vice-versa. The name is acts as a reference to the values 1 through 6. This concept is clearly demonstrated by binding the existing values in x to y. This action doesn't create a copy of `(1:6)`, but binds the values to a new name `y`. This doesn't mean that you won't see two names in your environment, instead, it shows that `y` is also referencing the sames values, `(1:6)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny <- x\n```\n:::\n\n\nHow do we know this? Well, we can access the object's identifier to make sure both `x` and `y` point to the same object `(1:6)`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint(lobstr::obj_addr(x))\n## [1] \"0x26ed68f2d38\"\nprint(lobstr::obj_addr(y))\n## [1] \"0x26ed68f2d38\"\n\n## Another example of this behavior\nprint(lobstr::obj_addr(mean))\n## [1] \"0x26ed2bedc98\"\nprint(lobstr::obj_addr(base::mean))\n## [1] \"0x26ed2bedc98\"\nprint(lobstr::obj_addr(match.fun(\"mean\")))\n## [1] \"0x26ed2bedc98\"\n```\n:::\n\n\n### Use syntactic names\n\nThe naming possibilities seem endless, but they're actually limited. Always use syntactic names that consists of letters, digits, `.` and `_`. You can't begin with `_` or a digit, and can't use any **reserved words** like `TRUE`, `FALSE`,`NULL`,`if`, and `function`^[Check out the complete list in `?Reserved`]. To override these rules, you have to surround the name in back–ticks. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`function` <- c(1:3,\"advance\",\"R\")\nprint(`function`)\n## [1] \"1\"       \"2\"       \"3\"       \"advance\" \"R\"\n\n`if` <- 1e+7\nprint(`if`)\n## [1] 1e+07\n```\n:::\n\nR will automatically convert non–syntactic names\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}