[
  {
    "objectID": "learn/epi/index.html#epi-by-design",
    "href": "learn/epi/index.html#epi-by-design",
    "title": "Epi & Stats",
    "section": "Epi by Design",
    "text": "Epi by Design\n\n\n    \n    \n                  \n            Jun, 24\n        \n        \n            Deault Title Here\n\n            \n\n            Subtitle Here\n            \n            \n        \n        \n        \n    \n    \n\n\nNo matching items"
  },
  {
    "objectID": "learn/advanceR/index.html#advanced-r",
    "href": "learn/advanceR/index.html#advanced-r",
    "title": "Programming",
    "section": "Advanced R",
    "text": "Advanced R\n\n\n    \n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "autotelic",
    "section": "",
    "text": "A site dedicated to my programming and statistics learning journey where I’ll record what I read, summarize, explain and learn from a wide variety of topics all related to programming, statistics, and occasionally, some other subjects.\nThe goal is that, within a 12-month period, I’ll be able to learn from three good, solid books and use this new found knowledge in my day–to–day life to create and improve something, however small it is. At the end of the year, I should see the tangible fruit of my labors, either virtually on the “interweb” or in physical form."
  },
  {
    "objectID": "learn/art/index.html#the-art-of-calligraphy",
    "href": "learn/art/index.html#the-art-of-calligraphy",
    "title": "Arts & Thangs",
    "section": "The Art of Calligraphy",
    "text": "The Art of Calligraphy\n\n\n    \n    \n                  \n            Jun, 24\n        \n        \n            Deault Title Here\n\n            \n\n            Subtitle Here\n            \n            \n        \n        \n        \n    \n    \n\n\nNo matching items"
  },
  {
    "objectID": "learn/advanceR/advanceR/chap1_4/index.html",
    "href": "learn/advanceR/advanceR/chap1_4/index.html",
    "title": "Chapters 1–4",
    "section": "",
    "text": "If you’d like to know your way around the programming environment, you first have to understand how R’s OOP works. Binding is one of the most basic functions performed in R so let’s start there:\n\nx &lt;- (1:6)\nprint(x)\n#| [1] 1 2 3 4 5 6\n\nR assigns values to a name, and not vice-versa. This code is creating an object, a vector with 6 elements. This object is then bound to the name x– which is also a variable. The name acts as a reference to the values 1 through 6. This concept is clearly demonstrated by binding the existing values in x to y. This action doesn’t create a copy of (1:6), but binds the same values to a new name y. This doesn’t mean that you won’t see two names in your environment, instead, it shows that y is also referencing (1:6).\n\ny &lt;- x\n\nHow do we know this? Well, we can access the object’s identifier to make sure both x and y point to the same object (1:6).\n\nprint(lobstr::obj_addr(x))\n#| [1] \"0x28a88236e38\"\nprint(lobstr::obj_addr(y))\n#| [1] \"0x28a88236e38\"\n\n## Another example of this behavior\nprint(lobstr::obj_addr(mean))\n#| [1] \"0x28a8c7c2cc8\"\nprint(lobstr::obj_addr(base::mean))\n#| [1] \"0x28a8c7c2cc8\"\nprint(lobstr::obj_addr(match.fun(\"mean\")))\n#| [1] \"0x28a8c7c2cc8\""
  },
  {
    "objectID": "learn/advanceR/advanceR/chap1_4/index.html#whats-in-a-name",
    "href": "learn/advanceR/advanceR/chap1_4/index.html#whats-in-a-name",
    "title": "Chapters 1–4",
    "section": "",
    "text": "If you’d like to know your way around the programming environment, you first have to understand how R’s OOP works. Binding is one of the most basic functions performed in R so let’s start there:\n\nx &lt;- (1:6)\nprint(x)\n#| [1] 1 2 3 4 5 6\n\nR assigns values to a name, and not vice-versa. This code is creating an object, a vector with 6 elements. This object is then bound to the name x– which is also a variable. The name acts as a reference to the values 1 through 6. This concept is clearly demonstrated by binding the existing values in x to y. This action doesn’t create a copy of (1:6), but binds the same values to a new name y. This doesn’t mean that you won’t see two names in your environment, instead, it shows that y is also referencing (1:6).\n\ny &lt;- x\n\nHow do we know this? Well, we can access the object’s identifier to make sure both x and y point to the same object (1:6).\n\nprint(lobstr::obj_addr(x))\n#| [1] \"0x28a88236e38\"\nprint(lobstr::obj_addr(y))\n#| [1] \"0x28a88236e38\"\n\n## Another example of this behavior\nprint(lobstr::obj_addr(mean))\n#| [1] \"0x28a8c7c2cc8\"\nprint(lobstr::obj_addr(base::mean))\n#| [1] \"0x28a8c7c2cc8\"\nprint(lobstr::obj_addr(match.fun(\"mean\")))\n#| [1] \"0x28a8c7c2cc8\""
  },
  {
    "objectID": "learn/advanceR/advanceR/chap1_4/index.html#changes-to-a-name",
    "href": "learn/advanceR/advanceR/chap1_4/index.html#changes-to-a-name",
    "title": "Chapters 1–4",
    "section": "Changes to a name",
    "text": "Changes to a name\nThe naming possibilities seem endless, but they’re actually limited. Always use syntactic names that consists of letters, digits, . and _. You can’t begin with _ or a digit, and can’t use any reserved words like TRUE, FALSE,NULL,if, and function1. To override these rules, you have to surround the name in back–ticks.\n\n`function` &lt;- c(1:3,\"ay\", \"caramba\")\nprint(`function`)\n#| [1] \"1\"       \"2\"       \"3\"       \"ay\"      \"caramba\"\n\n`if` &lt;- 1e+7\nprint(`if`)\n#| [1] 1e+07\n\nWhat happens when I modify y? Do I get a new object or the same object, \"0x1c7fb8fc418\" with new values? A new object is created, but the original object (1;6), did not change2. R simply created a new object with one value changed, and rebound y to it.\n\nx &lt;- 1:6\ny &lt;- x\ncat(tracemem(y), \"\\n\")\n#&gt; &lt;0000023889E515A0&gt;\n\n# Modified object\ny[[6]] &lt;- 10\n\n#&gt; tracemem[0x0000023889e515a0 -&gt; 0x0000023891546ef8]: \n#&gt; tracemem[0x0000023891546ef8 -&gt; 0x0000023890d854f8]: \n\nuntracemem(y) # to stop tracing y\n\n# Using a function to test this concept\nf &lt;- function(a){\n  a\n}\n\ncat(tracemem(x), \"\\n\")\n\nz &lt;- f(x)\n# no copy made. Bound z to (1:6)\n\nuntracemem(x)\n\nWe just performed copy-on modify3 and, hopefully, realized that R objects are immutable– once created, it will stay unchanged4.\nLists\nLists store elements that point to a specific value, just like variables; however, R uses shallow copy–on modify when binding values to a new list. In other words, the list object and its bindings are copied, but not the values to which the elements are pointing.\n\nl1 &lt;- list(c(1:4),\"a\")\nlobstr::obj_addr(l1)\n#| [1] \"0x28a8f2c8f08\"\n\nl2 &lt;- l1\nlobstr::obj_addr(l2)\n#| [1] \"0x28a8f2c8f08\"\n\n# Modify l2\nl2[[3]] &lt;- 25\nlobstr::obj_addr(l2)\n#| [1] \"0x28a8ead69b8\"\n\n## Let's look at values shared across lists\nlobstr::ref(l1,l2)\n#| █ [1:0x28a8f2c8f08] &lt;list&gt; \n#| ├─[2:0x28a8f2c9008] &lt;int&gt; \n#| └─[3:0x28a8d0f7580] &lt;chr&gt; \n#|  \n#| █ [4:0x28a8ead69b8] &lt;list&gt; \n#| ├─[2:0x28a8f2c9008] \n#| ├─[3:0x28a8d0f7580] \n#| └─[5:0x28a8d0f72e0] &lt;dbl&gt;\n\nData frames\nData frames are lists of vectors so modifying a column– one list– will not affect the binding of the other columns. However, modifying a row forces R to copy every column in the data frame.\n\nd1 &lt;- data.frame(x = (1:6), y = (7:12))\nlobstr::obj_addr(d1)\n#| [1] \"0x28a8eb08348\"\n\nd2 &lt;- d1\nlobstr::obj_addr(d2)\n#| [1] \"0x28a8eb08348\"\n\n# Modify one column\nd2[,2] &lt;- d2[,2] * 3\nref(d1,d2)\n#| █ [1:0x28a8eb08348] &lt;df[,2]&gt; \n#| ├─x = [2:0x28a8db1b228] &lt;int&gt; \n#| └─y = [3:0x28a8db1b110] &lt;int&gt; \n#|  \n#| █ [4:0x28a8ef11238] &lt;df[,2]&gt; \n#| ├─x = [2:0x28a8db1b228] \n#| └─y = [5:0x28a8f35eaf8] &lt;dbl&gt;\n\n# Modify one row\nd3 &lt;- d1\nd3[1,]&lt;- d3[1,] *3\nref(d1,d3)\n#| █ [1:0x28a8eb08348] &lt;df[,2]&gt; \n#| ├─x = [2:0x28a8db1b228] &lt;int&gt; \n#| └─y = [3:0x28a8db1b110] &lt;int&gt; \n#|  \n#| █ [4:0x28a8ed4ff38] &lt;df[,2]&gt; \n#| ├─x = [5:0x28a8eeb06f8] &lt;dbl&gt; \n#| └─y = [6:0x28a8eeb0618] &lt;dbl&gt;\n\nCharacter vectors\nR uses a global string pool where each element in a character vector is a pointer to a unique string in the pool.\n\nchar &lt;- c(\"a\",\"a\",\"abc\",\"d\")\nlobstr::ref(char, character = T)\n#| █ [1:0x28a8ef191d8] &lt;chr&gt; \n#| ├─[2:0x28a88e5c750] &lt;string: \"a\"&gt; \n#| ├─[2:0x28a88e5c750] \n#| ├─[3:0x28a8dd677d0] &lt;string: \"abc\"&gt; \n#| └─[4:0x28a8937a6b0] &lt;string: \"d\"&gt;\n\n\n\n\n\n\n\n\n\nA little bit of functions\nLet’s see how R’s binding behavior affects performance by using two simple functions and comparing the speed as the number of columns increase.\n\n# Define function to create random data\nmake.rand &lt;- function(nrow,ncol){\n  set.seed(2899)\n  ran.matrix &lt;- matrix(runif(nrow * ncol)\n                       ,nrow = nrow)\n  as.data.frame(ran.matrix)\n}\n\n# Create function to perform simple operation on:\n# Data frames\nsum.df &lt;- function(x,means){\n  means &lt;- vapply(x,mean,numeric(1))\n  for(i in seq_along(means)){\n    x[[i]] &lt;- x[[i]] + means[[i]]\n  }\n  x\n}\n\n# and lists\nsum.list &lt;- function(x,means){\n  x &lt;- as.list(x)\n  x &lt;- sum.df(x,means)\n  list2DF(x) # using list2DF to level performance of both functions\n}\n\nmake.rand(2,2) # testing function with 2×2 matrix\n#|      V1     V2\n#| 1 0.250 0.7588\n#| 2 0.422 0.0154\n\n\n\n\n\n\n\nAs a rule of thumbs, initialize vectors outside of loops. Move the computation of the means vector inside the for loop, and you will notice a 17,000% increase in computation time.\n\n\n\nI’ve created two functions to wrap the mean addition of a data frame and a list of randomly generated data. Next, I’ll create a function to evaluate performance of each operation on dfs and lists and thus the overhead of for loops5.\n\n# Function to create ran. data, calc. mean add., and eval. performance.\nbench.means &lt;- function(ncol){\n  df &lt;- make.rand(nrow = 1e4,ncol = ncol)\n  means &lt;- vapply(df,mean,numeric(1), USE.NAMES = F)\n  \n  bench::mark(\"data frame\" = sum.df(df,means),\n              \"list\" = sum.list(df,means),\n              time_unit = \"ms\")\n}\n\nbench.means(1) # testing function w. 1 column\n#| # A tibble: 2 × 6\n#|   expression    min median `itr/sec` mem_alloc `gc/sec`\n#|   &lt;bch:expr&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#| 1 data frame 0.0441 0.0980     9471.     105KB     14.6\n#| 2 list       0.0440 0.0977     9575.    93.3KB     16.3\n\nUsing bench::press() I’ll iterate over a vector of columns to evaluate performance speed as ncol increases and then visualize the execution time for data frames and lists.\n\n\nresults &lt;- bench::press(\n  ncol = c(1,10,35,75,100,300,500,650,800),\n  bench.means(ncol)\n)\n\n# Customize fonts\nfont_add_google(\"Libre Franklin\",\"libre\")\nshowtext_auto()\ntext &lt;- \"libre\"\n\n# Custom color palette\ncols &lt;- c(\"#80ADBF\",\"#7c225c\")\n\n# Create custom plot\nggplot(results,\n       aes(ncol,median,col = attr(expression,\"description\"))) +\n  geom_point() +\n  geom_smooth(se = FALSE) +\n  labs(x = \"Number of columns\",\n       y = \"Execution Time (ms)\",\n       colour = \"Data Structure\") +\n  scale_color_manual(values = cols) +\n  theme_minimal() +\n  theme(legend.position = \"top\",\n        legend.title = element_text(family = text, size = 23),\n        legend.text = element_text(family = text, size = 18),\n        plot.background = element_rect(fill = \"#dfe8f3\",\n                                       color = \"NA\"),\n        axis.title = element_text(family = text, size = 18,\n                                  hjust = .5),\n        axis.text = element_text(family = text,size = 16),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()\n        )\n\n\n\n\n\n\n\n\nx &lt;- make.rand(nrow = 1e4,ncol = 5)\nmeans &lt;- vapply(x,mean,numeric(1))\n\nfor(i in seq_along(means)){\n  x[[i]] &lt;- x[[i]] + means[[i]]\n}\n\n# How many times is the data frame copied during one iteration?\ncat(tracemem(x), \"\\n\")\n# &lt;0x000001b594610f08&gt;\n\nfor(i in 1:2){\n  x[[i]] &lt;- x[[i]] + means[[i]]\n}\n\n# tracemem[0x000001b594610f08 -&gt; 0x000001b597fb9468]\n# tracemem[0x000001b597fb9468 -&gt; 0x000001b597fb93f8]: [[&lt;-.data.frame [[&lt;-\n# tracemem[0x000001b597fb93f8 -&gt; 0x000001b597fb9388]\n# tracemem[0x000001b597fb9388 -&gt; 0x000001b597fb9318]: [[&lt;-.data.frame [[&lt;-\n\nuntracemem(x)\n\nThe execution time for a data frame is significantly higher after a few hundred columns are added. R’s copy-on modify behavior creates three copies of the data frame with each iteration of the for loop while a list is only copied once. This behavior is not problematic for a few columns so this approach may not pay off."
  },
  {
    "objectID": "learn/advanceR/advanceR/chap1_4/index.html#vectors",
    "href": "learn/advanceR/advanceR/chap1_4/index.html#vectors",
    "title": "Chapters 1–4",
    "section": "Vectors",
    "text": "Vectors\nVectors comes in two flavors, atomic6 and lists. There are four primary types of atomic vectors: logical, integer, double, and character. We refer to integer and double vectors as numeric. There are also complex and raw vectors to deal with complex numbers and binary data7.\n\n\n\n\n\nflowchart LR\n  A[Logical] ---&gt; B((Atomic))\n  B --&gt; C{Vector}\n  E(Numeric) --&gt; B\n  D[Character] ---&gt; B\n  F[Double] --&gt; E\n  G[Integer] --&gt; E\n\n\n\n\n\n\nTo create scalars8 of each type of atomic vectors we use TRUE or FALSE9 for logicals. Doubles are specified in decimal, scientific or hexadecimal form and can take three special forms, Inf, -Inf, and NaN. Integers are written like doubles but must be followed by L, while strings are surrounded by \" or '.\n\ndbl &lt;- c(1.2,2.45,3.0)\nint &lt;- c(1,6,10,4)\nlog &lt;- c(TRUE,FALSE,TRUE,FALSE)\nchar &lt;- c(\"TRUE\",\"FALSE\",\"TRUE\",\"FALSE\")\n\ntypeof(dbl); length(dbl)\n#| [1] \"double\"\n#| [1] 3\ntypeof(int); length(int)\n#| [1] \"double\"\n#| [1] 4\ntypeof(log); length(log)\n#| [1] \"logical\"\n#| [1] 4\ntypeof(char); length(char)\n#| [1] \"character\"\n#| [1] 4\n\n# NA values\n# Most computations involving a missing value will return a missing value\nNA * 5\n#| [1] NA\nNA &gt; 10\n#| [1] NA\n!NA\n#| [1] NA\nNA^0\n#| [1] 1\nNA | TRUE # TRUE has a value of 1\n#| [1] TRUE\nNA & FALSE # FALSE has a value of 0\n#| [1] FALSE\n\n# Missing values propagate\nx &lt;- c(NA,5,10,13,NA)\nx == NA\n#| [1] NA NA NA NA NA\n#Use is.na() instead\nis.na(x)\n#| [1]  TRUE FALSE FALSE FALSE  TRUE\n\nInstead of testing whether you’re working with a vector using is.vector() or is.atomic, or is.numeric()10; use more specific commands like is.logical(), is.double(), is.integer(),is.character(). For atomic vectors, type is a property of the entire vector– all elements must be of the same type. This will be forcibly achieved by automatic coercion in a pre-determined order:\n\n\n\n\n\nflowchart LR\nA(character) --&gt; B(double) \nB --&gt; C(integer) \nC --&gt; D(logical)\n\n\n\n\n\n\nHowever, you can deliberately coerce an object by using as.*(); however, you run the risk of producing NA if the object cannot be coerced, i.e, coercing character strings to numeric objects.\nAttributes\nVectors do not include matrices, arrays,factors, or date–time objects. These types are built as attributes of a vector. These attributes are name–value pairs that attach metadata to an object. You can set attributes with structure(), and retrieved with attr() and attributes(), individually or collectively. However, most attributes, except names and dim, are lost by most operations, unless you create an S3 class for them.\n\na &lt;- 1:3\na &lt;- structure(1:3,\n  x = \"ay\",\n  y = \"caramba\"\n)\n\nstr(attributes(a))\n#| List of 2\n#|  $ x: chr \"ay\"\n#|  $ y: chr \"caramba\"\n\n#Don't use attr(a,\"names\") to assign names to elements in an object.\n# Instead use one of these three options:\nb &lt;- c(d = c(\"1,2,3\"),e = \"ay\", f = \"caramba\") \n\n# or use names()#\nb &lt;- c(\"1,2,3\",\"ay\",\"caramba\")\nnames(b) &lt;- c(\"d\",\"e\",\"f\")\n\n# or Inline, with setNames #\nb &lt;- setNames(c(\"1,2,3\",\"ay\",\"caramba\"), c(\"d\",\"e\",\"f\"))\n\nThe dim attribute allows a vector to behave like a two–dimensional matrix or a multi–dimensional array. Matrices and arrays can therefore be created in place by using the dim() command or matrix() and array()\n\n\n\nCommand Generalizations\n\nVector\nMatrix\nArray\n\n\n\nnames()\nrownames(), colnames()\ndimnames()\n\n\nlength()\nnrow(), ncol()\ndim()\n\n\nc()\nrbind(),cbind()\nabind::abind()\n\n\n—\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\n\n\nS3 Vectors\nThe class attribute turns vectors into S3 objects. S3 objects are built on top of a base type, and store additional information in other attributes. Four important S3 vectors used in R are factors, categorical data with values represening a fixed set of levels;date vectors, date—times stored in POSIXct, and difftime to represent durations.\n\n\n\n\n\nflowchart LR\n  A[Logical] ---&gt; B((Atomic))\n  B --&gt; C{Vector}\n  E(Numeric) --&gt; B\n  D[Character] ---&gt; B\n  F[Double] --&gt; E\n  G[Integer] --&gt; E\n  H[/factor/] --&gt;G\n  I[/POSIXct/] --&gt;F\n  J[/Date/] --&gt; F\n\n\n\n\n\n\nFactors\nFactors are built on top of an integer vector with two attributes: a class “factor” and levelsto define the set of allowed values. Tabulating factor vectors will get you a count of all categories, observed and unobserved, which is not the case with character vectors. Ordered factors are a variation of factors where the order of levels is meaningful(poor, good, best).\n\nf &lt;- factor(c(\"ay\", \"ay\",\"caramba\",\"caramba\",\"123\"))\nprint(f)\n#| [1] ay      ay      caramba caramba 123    \n#| Levels: 123 ay caramba\n\ntypeof(f)\n#| [1] \"integer\"\n\n# Factor levels count\ngender &lt;- c(\"m\",\"m\",\"m\")\ngender_factor &lt;- factor(gender, levels = c(\"m\",\"f\"))\n\n# Tabulate\ntable(gender)\n#| gender\n#| m \n#| 3\ntable(gender_factor)\n#| gender_factor\n#| m f \n#| 3 0\n\n# Ordered Factors\nhealth &lt;- ordered(c(\"poor\",\"good\",\"poor\",\"best\",\"good\"), \n                  levels = c(\"poor\",\"good\",\"best\"))\nprint(health)\n#| [1] poor good poor best good\n#| Levels: poor &lt; good &lt; best\n\nDates & Date—times\nDate vectors are built on top of double vectors and only have one attribute, class. The value of the double vector, after stripping the class, represents the number of days since the Unix epoch(1970-01-01).\nDate—times vector come in two formats, POSIXct and POSIXlt, built on top of double vectors, where the values of POSIXct, calendar time, represents the number of seconds since the Unix epoch.\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n#| [1] \"double\"\nattributes(today)\n#| $class\n#| [1] \"Date\"\n\ndate &lt;- as.Date(\"1970-02-02\")\nunclass(date)\n#| [1] 32\n\n# Date-times\npoint_ct &lt;- as.POSIXct(\"2020-02-02\", tz = \"UTC\") # tz is timezone\nprint(point_ct)\n#| [1] \"2020-02-02 UTC\"\ntypeof(point_ct)\n#| [1] \"double\"\nattributes(point_ct)\n#| $class\n#| [1] \"POSIXct\" \"POSIXt\" \n#| \n#| $tzone\n#| [1] \"UTC\"\n\nDurations\nDurations represent the amount of time between pairs of dates or date—times stored as “difftimes”. Difftimes are also built on top of doubles and have a units attribute that determines how the integer is interpreted.\n\nweek &lt;- as.difftime(1,units = \"weeks\")\nprint(week)\n#| Time difference of 1 weeks\ntypeof(week)\n#| [1] \"double\"\nattributes(week)\n#| $class\n#| [1] \"difftime\"\n#| \n#| $units\n#| [1] \"weeks\"\n\nweek_days &lt;- as.difftime(7,units = \"days\")\nprint(week_days)\n#| Time difference of 7 days\ntypeof(week_days)\n#| [1] \"double\"\nattributes(week_days)\n#| $class\n#| [1] \"difftime\"\n#| \n#| $units\n#| [1] \"days\"\n\nLists"
  },
  {
    "objectID": "learn/advanceR/advanceR/chap1_4/index.html#footnotes",
    "href": "learn/advanceR/advanceR/chap1_4/index.html#footnotes",
    "title": "Chapters 1–4",
    "section": "Footnotes",
    "text": "Footnotes\n\nCheck out the complete list of restricted names in ?Reserved↩︎\nALTREP, or alternative representation, allows R to represent certain vectors in a very compact fashion. Number sequences are one example of this behavior since only the first and last numbers are stored. For this reason every sequence is the same size, 680B.↩︎\nIf an object has a single name bound to it, R will modify–in–place–the new value will be appended to the same object.↩︎\nWhen an object is not longer bound to a name, the garbage collector will delete it to free up memory↩︎\neach iteration of the loop copies the data frame three times. Ideally, this behavior is reduced by using lists↩︎\nwhen the inputs of a vector are atomic, the resulting vector will also be atomic. This is called flattening.↩︎\nReview the documentation for as.raw() and as.complex().↩︎\na special syntax to create an individual value↩︎\nalso abbreviated as T and F↩︎\nThese commands don’t test if you have a vector. Review the documentation to figure out what they do.↩︎"
  }
]